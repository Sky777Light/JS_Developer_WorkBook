<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Capturing/bubbling, delegation, custom events</title>
</head>
<body>

<div onclick="SomeFunc()"></div>


<script>
    document.body.addEventListener("click", function () {
        SomeFunc();
    });

    document.body.addEventListener("click", SomeFunc);
    document.body.removeEventListener("click", SomeFunc);

   function SomeFunc() {
       console.log(123)
   }

   /**обьект Event
    bubbles: возвращает true, если событие является восходящим. Например, если событие возникло на вложенном элементе, то оно может быть обработано на родительском элементе.
    cancelable: возвращает true, если можно отменить стандартную обработку события
    currentTarget: определяет элемент, к которому прикреплен обработчик события
    defaultPrevented: возвращает true, если был вызван у объекта Event метод preventDefault()
    eventPhase: определяет стадию обработки события
    target: указывает на элемент, на котором было вызвано событие
    timeStamp: хранит время возникновения события
    type: указывает на имя события   */

   e.preventDefault(); // запрещает стандартное выполнение (к примеру клик по ссылке отменит переход по url, клик по submit в форме отменит передачу формы на сервер)

</script>

delegation
    вместо клика на каждый елемент мы создаем событие при клике на его родителя и через event.target работаем с елементом на который кликнули.
    можно добавить классы и проверять через налицие классов стоит ли выполнять функцию по клику на этот елемент или нет

Capturing/bubbling
    bubbling   событие распространяется вверх по дереву DOM от дочерних узлов к родительским

            <div id="blueRect">
                <div id="redRect"></div>
            </div>



            redRect.addEventListener("click", function(){
                console.log("Событие на redRect");
            });

            var blueRect = document.getElementById("blueRect");
            blueRect.addEventListener("click", function(){
                console.log("Событие на blueRect");
            });

            document.body.addEventListener("click", function(){
                console.log("Событие на body");
            });


            клик по redRect => событие распространяется redRect => blueRect => body

            e.stopPropagation(); - остановит распространение - событие выполнится только на redRect


        По умолчанию все события восходящие.

    Capturing   событие распространяется вниз по дереву DOM от родительских узлов к дочерним, пока не достигнет того элемента, на котором это событие и возникло

            <div id="blueRect">
                <div id="redRect"></div>
            </div>
            клик по redRect => событие распространяется body => blueRect => redRect


        redRect.addEventListener("click", function(){
            console.log("Событие на redRect");
        }, true);

        true - включит нисходяшие события (по умолчанию в addEventListener третий параметр false)



события мыши
    click: возникает при нажатии указателем мыши на элемент
    mousedown: возникает при нахождении указателя мыши на элементе, когда кнопка мыши находится в нажатом состоянии
    mouseup: возникает при нахождении указателя мыши на элементе во время отпускания кнопки мыши
    mouseover: возникает при вхождении указателя мыши в границы элемента
    mousemove: возникает при прохождении указателя мыши над элементом
    mouseout: возникает, когда указатель мыши выходит за пределы элемента

    обьект event
        altKey: возвращает true, если была нажата клавиша Alt во время генерации события
        button: указывает, какая кнопка мыши была нажата
        clientX: определяет координату Х окна браузера, на которой находился указатель мыши во время генерации события
        clientY: определяет координату Y окна браузера, на которой находился указатель мыши во время генерации события
        ctrlKey: возвращает true, если была нажата клавиша Ctrl во время генерации события
        metaKey: возвращает true, если была нажата во время генерации события метаклавиша клавиатуры
        relatedTarget: определяет вторичный источник возникновения события
        screenX: определяет координату Х относительно верхнего левого угла экрана монитора, на которой находился указатель мыши во время генерации события
        screenY: определяет координату Y относительно верхнего левого угла экрана монитора, на которой находился указатель мыши во время генерации события
        shiftKey: возвращает true, если была нажата клавиша Shift во время генерации события

события клавиатуры
        keydown: возникает при нажатии клавиши клавиатуры и длится, пока нажата клавиша
        keyup: возникает при отпускании клавиши клавиатуры
        keypress: возникает при нажатии клавиши клавиатуры, но после события keydown и до события keyup.
                        Надо учитывать, что данное событие генерируется только для тех клавиш, которые формируют вывод в виде символов, например, при печати символов.
                        Нажатия на остальные клавиши, например, на Alt, не учитываются.

        обьект event
            altKey: возвращает true, если была нажата клавиша Alt во время генерации события
            charCode: возвращает символ Unicode для нажатой клавиши (используется для события keypress)
            keyCode: возвращает числовое представление нажатой клавиши клавиатуры
            ctrlKey: возвращает true, если была нажата клавиша Ctrl во время генерации события
            metaKey: возвращает true, если была нажата во время генерации события метаклавиша клавиатуры
            shiftKey: возвращает true, если была нажата клавиша Shift во время генерации события

создание кастомных событий
    var event = new Event(тип события[, флаги]);

    Тип события – может быть как своим, так и встроенным, к примеру "click".
    Флаги –  { bubbles: true/false, cancelable: true/false }
                bubbles указывает, всплывает ли событие, (bubbling or capturing)
                cancelable – можно ли отменить действие по умолчанию. (e.preventDefault() )
    Флаги по умолчанию: {bubbles: false, cancelable: false}.

    Затем, чтобы инициировать событие, запускается elem.dispatchEvent(event)




var event = new Event('build');

// Подписываемся на событие
elem.addEventListener('build', function (e) { ... }, false);

// Вызываем событие
elem.dispatchEvent(event);

все это работает как паттерн обсервер

</body>
</html>